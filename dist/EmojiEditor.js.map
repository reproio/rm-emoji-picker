{"version":3,"sources":["../src/js/EmojiEditor.js"],"names":["EmojiEditor","input","prevent_new_line","_input","_is_content_editable","isContentEditable","cursor_position","undefined","_trackCursor","_onPaste","element","tag","nodeName","emoji","focus","restoreSelection","node","supportsUnified","pasteTextAtCaret","getCharacter","selectElement","pasteHtml","getHtml","trigger","text","ret","pasteInputText","selectionStart","current_length","value","length","substr","setInputCaretPosition","position","createTextRange","range","move","select","setSelectionRange","_mapElement","replace","withUnified","replace_colons","innerHTML","off","on","event","stopPropagation","preventDefault","clipboard_data","originalEvent","clipboardData","window","pasted_data","getData","Array","prototype","slice","call","childNodes","nodes","getNodes","saveSelection","el","children","map","is_text","Text","is_html","HTMLElement","textContent","tagName","_extractSpan","_extractImage","join","which","converter","withEnvironment","html","replace_unified","selectElementContents","Error","span","$span","$inner","find","codepoint","data","parseCodepoints","err","img","hasAttribute","getAttribute","codepoints","test","arr","split","one","two","String","fromCodePoint","replace_mode","pasteHtmlAtCaret","getSelection","sel","getRangeAt","rangeCount","document","selection","createRange","removeAllRanges","addRange","createTextNode","deleteContents","insertNode","highlight","selectNodeContents","collapse","text_range","body","moveToElementText","select_pasted_content","createElement","frag","createDocumentFragment","last_node","firstChild","appendChild","first_node","cloneRange","setStartAfter","setStartBefore","type","original_range","pasteHTML","setEndPoint"],"mappings":"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","file":"EmojiEditor.js","sourcesContent":["import $ from \"jquery\";\nimport Converters from \"./Converters\";\n\n\"use strict\";\n\nexport default class EmojiEditor {\n\n    /**\n     *\n     * @param {HTMLElement|HTMLTextAreaElement|HTMLInputElement} input\n     * @param {Boolean} prevent_new_line\n     */\n    constructor(input, prevent_new_line = false){\n        /**\n         *\n         * @type {HTMLElement|HTMLTextAreaElement|HTMLInputElement}\n         * @private\n         */\n        this._input = input;\n\n        /**\n         * @type {Boolean}\n         * @private\n         */\n        this._is_content_editable = this.isContentEditable(input);\n\n        /**\n         *\n         * @type {Range|undefined}\n         */\n        this.cursor_position = undefined;\n\n        /**\n         *\n         * @type {boolean}\n         */\n        this.prevent_new_line = prevent_new_line;\n\n        this._trackCursor();\n        this._onPaste();\n    }\n\n    /**\n     * Check if an input element is contenteditable.\n     *\n     * (IE11 marks textareas as contenteditable (!))\n     * @param {HTMLElement|HTMLTextAreaElement|HTMLInputElement} element\n     */\n    isContentEditable (element) {\n         const tag = element.nodeName\n         return element.isContentEditable && tag !== \"INPUT\" && tag !== \"TEXTAREA\"\n    }\n\n    /**\n     * Pastes an emoji at the caret taking into account whether the element\n     * is contenteditable or not.\n     *\n     * @param {Emoji} emoji\n     */\n    placeEmoji(emoji){\n        this._input.focus();\n        if(this.cursor_position){\n            EmojiEditor.restoreSelection(this.cursor_position);\n        }\n        if(this._is_content_editable){\n            let node;\n            if(EmojiEditor.supportsUnified()){\n                node = EmojiEditor.pasteTextAtCaret(emoji.getCharacter());\n                EmojiEditor.selectElement(node);\n            }\n            else {\n                node = EmojiEditor.pasteHtml(emoji.getHtml());\n            }\n            $(this._input).trigger('change', [true]).trigger('input', [true]);\n            return node;\n        }\n        else {\n            let text = emoji.getCharacter();\n            var ret = this.pasteInputText(text);\n            $(this._input).trigger('change', [true]).trigger('input', [true]);\n            return ret;\n        }\n    }\n\n    /**\n     * Pastes text at the cursor while preserving cursor position.\n     *\n     * @param text\n     * @return {String}\n     */\n    pasteInputText(text){\n        const cursor_position = this._input.selectionStart;\n        const current_length  = this._input.value.length;\n        this._input.value     = this._input.value.substr(0, cursor_position)\n                                + text\n                                + this._input.value.substr(cursor_position);\n\n        this.setInputCaretPosition(cursor_position + this._input.value.length - current_length);\n        return text;\n    }\n\n    /**\n     * Sets the caret position on a textarea or input[type=text] field\n     *\n     *\n     * @param position\n     * @returns {boolean}\n     */\n    setInputCaretPosition(position){\n        if(this._input.createTextRange){\n            const range = this._input.createTextRange();\n            range.move('character', position);\n            range.select();\n            return true;\n        }\n        else {\n            if(this._input.selectionStart || this._input.selectionStart === 0){\n                this._input.focus();\n                this._input.setSelectionRange(position, position);\n                return true;\n            }\n            //Otherwise this method failed (browser not supported)\n            else{\n                this._input.focus();\n                return false;\n            }\n        }\n    }\n\n    /**\n     * Gets the text from the input\n     *\n     * @returns {*}\n     */\n    getText() {\n        if(this._is_content_editable){\n            return this._mapElement(this._input)\n                       .replace(/[\\u200B-\\u200D\\uFEFF]/g, '');\n        }\n\n        return Converters.withUnified().replace_colons(this._input.value);\n    }\n\n    /**\n     * Empty the input's contents.\n     */\n    empty () {\n        if(this._is_content_editable){\n            this._input.innerHTML = \"\";\n        }\n        else{\n            this._input.value = \"\";\n        }\n    }\n    /**\n     * Intercepts paste events for contenteditable divs so that we don't get\n     * any of the special html that gets inserted automatically.\n     *\n     * @returns {EmojiEditor}\n     * @private\n     */\n    _onPaste(){\n        if(this._is_content_editable){\n            $(this._input).off('paste.editable').on('paste.editable', event => {\n                event.stopPropagation();\n                event.preventDefault();\n\n                const clipboard_data = event.originalEvent.clipboardData || window.clipboardData;\n                const pasted_data    = clipboard_data.getData('text');\n                const text           = EmojiEditor.pasteTextAtCaret(pasted_data);\n                EmojiEditor.selectElement(text);\n            });\n        }\n\n        return this;\n    }\n\n    /**\n     * Get all of the child nodes in an input\n     *\n     * @returns {Array<Node>}\n     */\n    getNodes () {\n        return Array.prototype.slice.call(this._input.childNodes);\n    }\n\n    /**\n     * Selects the last node in the input.\n     */\n    selectLastNode(){\n        const nodes = this.getNodes();\n        if(nodes.length){\n            EmojiEditor.selectElement(nodes[nodes.length - 1]);\n            this.cursor_position = EmojiEditor.saveSelection();\n        }\n    }\n\n    /**\n     * Extracts just text and emojis from a contenteditable element\n     *\n     * @param {HTMLElement} el\n     * @private\n     */\n    _mapElement(el){\n\n        const children = Array.prototype.slice.call(el.childNodes);\n\n        return children.map(/**Text|HTMLElement*/node => {\n\n            const is_text = node instanceof Text;\n            const is_html = node instanceof HTMLElement;\n\n            //Return all text from text nodes\n            if(is_text){\n                return node.textContent;\n            }\n            //Extract codepoints from span\n            else if(is_html && node.tagName === \"SPAN\"){\n                return EmojiEditor._extractSpan(node);\n            }\n\n            //Extract codepoints from an image if it was supplied\n            else if(is_html && node.tagName === \"IMG\"){\n                return EmojiEditor._extractImage(node);\n            }\n\n            //Convert br tags to line breaks\n            else if(is_html && node.tagName === \"BR\"){\n                return \"\\n\";\n            }\n\n            //if the element is not html we're accounting for run it back through this function\n            else if(is_html){\n                return this._mapElement(node);\n            }\n            else {\n                //Unaccounted for situation - just return a blank string\n                return \"\";\n            }\n        }).join(\"\");\n    }\n\n    /**\n     * Tracks the cursor position and monitors the enter button in case prevent_new_line is true\n     *\n     * @returns {EmojiEditor}\n     * @private\n     */\n    _trackCursor(){\n        if(this._is_content_editable){\n            $(this._input).off('keyup.emoji mouseup.emoji').on('keyup.emoji mouseup.emoji', () => {\n                this.cursor_position = EmojiEditor.saveSelection();\n            });\n\n            $(this._input).off('keydown.emoji').on('keydown.emoji', event => {\n                if(event.which === 13 && this.prevent_new_line){\n                    event.preventDefault();\n                }\n            });\n        }\n\n        return this;\n    }\n    /**\n     * Extracts the text content from a contenteditable and extracts any spans.\n     *\n     * @param span\n     * @returns {String}\n     * @private\n     */\n    static _extractSpan(span){\n        const $span = $(span);\n        const $inner = $span.find('.emoji-inner');\n        //If the span was not inserted by the emoji picker\n        if(!$inner.length){\n            return \"\";\n        }\n        //If the span was inserted by the emoji picker, get the codepoints and return the corresponding character\n        try {\n            const codepoint = $inner.data('codepoints');\n            return EmojiEditor.parseCodepoints(codepoint);\n        }\n        catch (err){\n            return \"\";\n        }\n    }\n\n    /**\n     * Extracts codepoints from an image if it exists.\n     *\n     * @param {HTMLElement} img\n     * @private\n     */\n    static _extractImage(img){\n        if(img.hasAttribute('data-codepoints')){\n            return EmojiEditor.parseCodepoints(\n                img.getAttribute('data-codepoints')\n            );\n        }\n\n        return \"\";\n    }\n\n    /**\n     * Parses codepoints that may come in the format\n     * `hex`-`hex` rather than just `hex`\n     *\n     * @param codepoints\n     * @returns {string}\n     */\n    static parseCodepoints(codepoints){\n\n        if(/-/g.test(codepoints)){\n            const arr = codepoints.split(\"-\");\n            const one = `0x${arr[0]}`;\n            const two = `0x${arr[1]}`;\n            return String.fromCodePoint(one,two);\n        }\n\n        return String.fromCodePoint(`0x${codepoints}`);\n    }\n\n    /**\n     * Replaces unified unicode inside of a contenteditable element with\n     * platform appropriate content.\n     *\n     */\n    replaceUnified () {\n\n        if(this._is_content_editable){\n            const converter = Converters.withEnvironment();\n            const html = converter.replace_unified(this._input.innerHTML);\n            EmojiEditor.selectElementContents(this._input);\n            const node = EmojiEditor.pasteHtml(html);\n            if(node){\n                EmojiEditor.selectElement(node);\n            }\n        }\n        else{\n            throw new Error(\"The replaceUnified method should only be called on contenteditable elements.\");\n        }\n\n    }\n\n\n    /**\n     * Determines if the environment supports unified unicode.\n     *\n     * @returns {boolean}\n     */\n    static supportsUnified (){\n        return Converters.withEnvironment().replace_mode === \"unified\";\n    }\n\n    /**\n     * Shortcut to paste html at the caret with a dummy unicode character.\n     *\n     * @param html\n     */\n    static pasteHtml(html){\n        return EmojiEditor.pasteHtmlAtCaret(html + \"&#8203;\");\n    }\n    /**\n     * saves the position of the cursor in a contenteditable div\n     *\n     * Credit goes to Tim Down here\n     *\n     * @returns {Range|null}\n     */\n    static saveSelection(){\n        if(window.getSelection){\n            const sel = window.getSelection();\n            if(sel.getRangeAt && sel.rangeCount){\n                return  sel.getRangeAt(0);\n            }\n        }\n        else if(document.selection && document.selection.createRange){\n            return document.selection.createRange();\n        }\n        return null;\n    }\n\n    /**\n     * Restores the selection using a Range object\n     *\n     * Credit goes to Tim Down here\n     *\n     * @param {Range} range\n     */\n    static restoreSelection(range){\n        if(range){\n            if(window.getSelection){\n                const sel = window.getSelection();\n                sel.removeAllRanges();\n                sel.addRange(range);\n            }\n            else if(document.selection && range.select){\n                range.select();\n            }\n        }\n    }\n\n    /**\n     * Pastes text at the caret position\n     *\n     * Credit goes to Tim Down here\n     *\n     * @param text\n     * @returns {Text}\n     */\n    static pasteTextAtCaret(text){\n        let sel, range;\n        const node = document.createTextNode(text);\n        if(window.getSelection){\n            sel = window.getSelection();\n            if(sel.getRangeAt && sel.rangeCount){\n                range = sel.getRangeAt(0);\n                range.deleteContents();\n                range.insertNode(node);\n            }\n        }\n        else if(document.selection && document.selection.createRange){\n            document.selection.createRange().text = node.textContent;\n        }\n\n        return node;\n    }\n\n\n    /**\n     * Selects an element an optionally highlights it. If it doesn't highlight,\n     * it just drops the cursor at the end of the element.\n     *\n     *\n     * Credit goes to Tim Down here\n     *\n     * @param element\n     * @param highlight\n     */\n    static selectElement(element, highlight = false){\n        if(window.getSelection){\n            const sel = window.getSelection();\n            sel.removeAllRanges();\n            const range = document.createRange();\n            range.selectNodeContents(element);\n            if(!highlight){\n                range.collapse(false);\n            }\n            sel.addRange(range);\n        }\n        else if(document.selection){\n            const text_range = document.body.createTextRange();\n            text_range.moveToElementText(element);\n            text_range.select();\n        }\n    }\n\n    /**\n     * Pastes html at the caret. Note that to do this without placing the\n     * cursor inside of the html you need to add a dummy unicode character.\n     * For our purposes we'll add the 0-width space and then strip it out when we parse the output\n     *\n     * Credit goes to Tim Down here\n     *\n     * @param html\n     * @param select_pasted_content\n     * @returns {*}\n     */\n    static pasteHtmlAtCaret (html, select_pasted_content){\n        let sel, range;\n        if(window.getSelection){\n            //IE9+ and non-IE\n            sel = window.getSelection();\n            if(sel.getRangeAt && sel.rangeCount){\n                range = sel.getRangeAt(0);\n                range.deleteContents();\n\n                const el = document.createElement(\"div\");\n                el.innerHTML = html;\n                let frag = document.createDocumentFragment(), node, last_node;\n                while((node = el.firstChild)){\n                    last_node = frag.appendChild(node);\n                }\n\n                const first_node = frag.firstChild;\n                range.insertNode(frag);\n\n                //Preserve the selection\n                if(last_node){\n                    range = range.cloneRange();\n                    range.setStartAfter(last_node);\n                    if(select_pasted_content){\n                        range.setStartBefore(first_node);\n                    }\n                    else{\n                        range.collapse(false);\n                    }\n                    sel.removeAllRanges();\n                    sel.addRange(range);\n                }\n\n                return first_node;\n            }\n        }\n        else if((sel = document.selection) && sel.type != \"Control\"){\n            // IE < 9\n            const original_range = sel.createRange();\n            original_range.collapse(true);\n            sel.createRange().pasteHTML(html);\n            if(select_pasted_content){\n                range = sel.createRange();\n                range.setEndPoint(\"StartToStart\", original_range);\n                range.select();\n            }\n        }\n    }\n\n    /**\n     * Selects the contents of an element.\n     *\n     *\n     * Credit goes to Tim Down here\n     *\n     * @param el\n     */\n    static selectElementContents(el){\n        const range = document.createRange();\n        range.selectNodeContents(el);\n        const sel = window.getSelection();\n        sel.removeAllRanges();\n        sel.addRange(range);\n    }\n}\n"]}